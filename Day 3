1、剔除null值
select device_id,gender,age,university
From user_profile
where age is not null

2、查找后排序
取出用户设备ID和用户年龄数据，并按照年龄升序排序。
Select device_id and gender 
from user_profile 
order by age ASC
注意：oder by 和 group by 不同。group by：有聚合作用，行数通常比原始行少，位置在where 后，order by 前。

3、查找后多列排序
有多个排序条件的情况
取出用户信息表中的device_id、年龄和gpa数据，并先按照gpa升序排序，再按照年龄升序排序输出。
select device_id, gpa,age
from user_profile
order by gpa ASC, age ASC

4、查找后降序排列
取出用户信息表中对应的数据，并先按照gpa降序排列、gpa相同的按照年龄降序排序输出
select device_id,gpa,age
from user_profile
order by gpa DESC, age DESC 

5、统计+筛选
取出2021年8月份所有练习过题目的总用户数和练习过题目的总次数
筛选条件：2021年8月份 -> date like "2021-08%"
统计：总用户数、练习过题目的总次数
select 
 count(distinct device_id) as did,
 count(question_id) as qui
from question_practice_detail
where date like "2021-08%"
注意：第二个 count 末尾没有 “，”

6、电话格式校验
电话号码必须是 10 位数字。
电话号码的第一位不能以 0 开头。
电话号码的格式可以是连续的 10 位数字，或以-分隔的格式（如123-456-7890）。
select *
from contacts
where phone_number REGEXP '^(?:[1-9][0-9]{9}|[1-9][0-9]{2}-[0-9]{3}-[0-9]{4})$'
order by id ASC

REGEXP是正则表达式匹配操作符
^ 表示匹配开头
$ 表示匹配结尾
[0-9] 匹配数字
[1-9] 保证首位不是 0
{n} 精确重复次数，如 {9} 表示 9 位
(pattern1|pattern2) 表示二选一
(?:...) 表示非捕获分组（MySQL 也支持）
两种电话号码格式
连续 10 位：^[1-9][0-9]{9}$
3-3-4 带横线：^[1-9][0-9]{2}-[0-9]{3}-[0-9]{4}$
合并规则
^(?:[1-9][0-9]{9}|[1-9][0-9]{2}-[0-9]{3}-[0-9]{4})$

7、窗口函数
请计算每一种产品每一天的累计利润，并按profit_date升序输出所有字段。
具体要求如下：1、计算每一天的累计利润。 2、输出结果按profit_date升序排列。
Select *,
sum(profit) over(order by profit_date) cumulative_profit
from daily_profits
order by profit_date 

窗口函数不会将结果汇总成一行，而是每行都有个结果。OVER子句包含分区（PARTITION BY）、排序 （ORDER BY）以及窗口大小（frame_clause）3 个选项。PARTITION BY 用于定义分区，类似于查询语句中的 GROUP BY 子句。ORDER BY 选项用于指定分区内数据的排序 
方式
ORDER BY = 给数据排队
PARTITION BY = 按组计算，但每一行都保留（窗口计算）
